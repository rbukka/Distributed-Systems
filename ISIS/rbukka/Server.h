
#include <sys/socket.h>
#include <netinet/in.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <string.h>
#include <iostream>
#include <string>
#include <vector>
#include <arpa/inet.h>
#include <netdb.h>
#include <errno.h>
#include <sys/time.h>
#include <math.h>
#include <map>
#include <algorithm>
#include <queue>
#include <fstream>
#include <set>


#define HOSTNAME_LEN 80
#define MAX_HOSTS 10
#define DEBUG 1
#define SIZE_ACK 8

#define ROUND_TIME 100000
#define UDP_RETRANSMIT_TIMER 5000
//#define ROUND_TIME 0.5
//#define UDP_RETRANSMIT_TIMER 0.1
#define TYPE_DM 1
#define TYPE_ACK 2
#define TYPE_SEQ_MSG 3

#define MAX_PACKET_SIZE 20


using namespace std;

class Key
{
  public: 
    Key(int seq, int pid)
    {
	     this->seq = seq;
	     this->pid = pid;
	  }
	  int seq;
	  int pid;
	  bool operator<(const Key& k) const
	  {
	      int s_cmp = (k.seq==this->seq);
	      if(s_cmp == 1)
		    {
			    return this->pid < k.pid;
			  }
			  return (k.seq>this->seq);
		}
};

void kprintf(const char* s)
{
	if(DEBUG)
		fprintf(stderr,"%s\n", s);
}

void kprintf(const char *s,int value)
{
	if(DEBUG)
		fprintf(stderr,"%s %d\n",s,value);
}

void kprintf(const char *s,char* value)
{
	if(DEBUG)
		fprintf(stderr,"%s %s\n",s,value);
}

void kprintf(const char *s,string value)
{
	if(DEBUG)
		fprintf(stderr,"%s %s\n",s,value.c_str());
}

/* Get current time. */
struct timeval* get_now( struct timeval *time) {
	if ( gettimeofday( time, NULL ) != 0 ) {
		fprintf(stderr,"Can't get current time.\n");
	}
	
	//printf("Second %ld Micro %ld\n",time->tv_sec,time->tv_usec);

	return time;
}

/* Convert "struct timeval" to fractional seconds. */
double time_to_seconds ( struct timeval *tstart, struct timeval *tfinish ) {
	double t;

	t = ((tfinish->tv_sec - tstart->tv_sec) + (tfinish->tv_usec - tstart->tv_usec)/pow(10,6))*pow(10,3) ;
	return t;
}

typedef struct {
	uint32_t type; // must be equal to 1
	uint32_t sender; // the sender's id
	uint32_t msg_id; // the identifier of the message generated by the sender
	uint32_t data; // a dummy integer
}DataMessage;

typedef struct {
		bool deliverable;
		int seq_num;
		DataMessage* data_msg;	
}DM;

typedef struct {
	uint32_t type; // must be equal to 2
	uint32_t sender; // the sender's id
	uint32_t msg_id; // the identifier of the message generated by the sender
	uint32_t proposed_seq; // the proposed sequence number
	uint32_t receiver; // the receiver's id
}AckMessage;

typedef struct {
	uint32_t type; // must be equal to 3
	uint32_t sender; // the sender's id
	uint32_t msg_id; // the identifier of the message generated by the sender
	uint32_t final_seq; // the final sequence number assigned by the sender
}SeqMessage;

